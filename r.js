/**
 * @license Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */

/*
 * This is a bootstrap script to allow running RequireJS in the command line
 * in either a Java/Rhino or Node environment. It is best to call this script
 * via the x script that is a sibling to it.
 */

/*jslint strict: false, evil: true */
/*global readFile: true, process: false, Packages: false, require: true
  print: false */

var console;
(function (args, readFileFunc) {

    var fileName, env, fs, vm, exec, rhinoContext,
        requireBuildPath = '',
        jsSuffixRegExp = /\.js$/,
        //This flag is turned to false by the distribution script,
        //because a requireBuildPath is not needed since the scripts
        //are inlined in this script.
        useRequireBuildPath = false,
        argOffset = useRequireBuildPath ? 0 : 1,
        readFile = typeof readFileFunc !== 'undefined' ? readFileFunc : null;

    if (typeof Packages !== 'undefined') {
        env = 'rhino';

        if (useRequireBuildPath) {
            requireBuildPath = args[0];
        }
        fileName = args[1 - argOffset];

        //Set up execution context.
        rhinoContext = Packages.org.mozilla.javascript.ContextFactory.getGlobal().enterContext();

        exec = function (string, name) {
            return rhinoContext.evaluateString(this, string, name, 0, null);
        };

        //Define a console.log for easier logging. Don't
        //get fancy though.
        if (typeof console === 'undefined') {
            console = {
                log: function () {
                    print.apply(undefined, arguments);
                }
            };
        }
    } else if (typeof process !== 'undefined') {
        env = 'node';

        //Get the fs module via Node's require before it
        //gets replaced. Used in require/node.js
        fs = require('fs');
        vm = require('vm');
        this.nodeRequire = require;
        require = null;

        readFile = function (path) {
            return fs.readFileSync(path, 'utf8');
        };

        exec = function (string, name) {
            return vm.runInThisContext(string, name);
        };

        if (useRequireBuildPath) {
            requireBuildPath = process.argv[2];
        }

        fileName = process.argv[3 - argOffset];
    }

    //Make sure build path ends in a slash.
    requireBuildPath = requireBuildPath.replace(/\\/g, '/');
    if (requireBuildPath.charAt(requireBuildPath.length - 1) !== "/") {
        requireBuildPath += "/";
    }

    //Actual base directory is up one directory from this script.
    requireBuildPath += '../';

    exec("/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS 0.23.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n/*jslint strict: false, plusplus: false */\n/*global window: false, navigator: false, document: false, importScripts: false,\n  jQuery: false, clearInterval: false, setInterval: false, self: false,\n  setTimeout: false */\n\nvar require, define;\n(function () {\n    //Change this version number for each release.\n    var version = \"0.23.0\",\n        commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg,\n        cjsRequireRegExp = /require\\([\"']([^'\"\\s]+)[\"']\\)/g,\n        currDirRegExp = /^\\.\\//,\n        jsSuffixRegExp = /\\.js$/,\n        ostring = Object.prototype.toString,\n        ap = Array.prototype,\n        aps = ap.slice,\n        apsp = ap.splice,\n        isBrowser = !!(typeof window !== \"undefined\" && navigator && document),\n        isWebWorker = !isBrowser && typeof importScripts !== \"undefined\",\n        //PS3 indicates loaded and complete, but need to wait for complete\n        //specifically. Sequence is \"loading\", \"loaded\", execution,\n        // then \"complete\". The UA check is unfortunate, but not sure how\n        //to feature test w/o causing perf issues.\n        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?\n                      /^complete$/ : /^(complete|loaded)$/,\n        defContextName = \"_\",\n        reqWaitIdPrefix = \"_r@@\",\n        empty = {},\n        contexts = {},\n        globalDefQueue = [],\n        interactiveScript = null,\n        isDone = false,\n        useInteractive = false,\n        //Default plugins that have remapped names, if no mapping\n        //already exists.\n        requirePlugins = {\n            \"text\": \"require/text\",\n            \"i18n\": \"require/i18n\",\n            \"order\": \"require/order\"\n        },\n        req, cfg = {}, currentlyAddingScript, s, head, baseElement, scripts, script,\n        src, subPath, mainScript, dataMain, i, scrollIntervalId, setReadyState, ctx;\n\n    function isFunction(it) {\n        return ostring.call(it) === \"[object Function]\";\n    }\n\n    function isArray(it) {\n        return ostring.call(it) === \"[object Array]\";\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     * This is not robust in IE for transferring methods that match\n     * Object.prototype names, but the uses of mixin here seem unlikely to\n     * trigger a problem related to that.\n     */\n    function mixin(target, source, force) {\n        for (var prop in source) {\n            if (!(prop in empty) && (!(prop in target) || force)) {\n                target[prop] = source[prop];\n            }\n        }\n        return req;\n    }\n\n    /**\n     * Used to set up package paths from a packagePaths or packages config object.\n     * @param {Object} pkgs the object to store the new package config\n     * @param {Array} currentPackages an array of packages to configure\n     * @param {String} [dir] a prefix dir to use.\n     */\n    function configurePackageDir(pkgs, currentPackages, dir) {\n        var i, location, pkgObj;\n\n        for (i = 0; (pkgObj = currentPackages[i]); i++) {\n            pkgObj = typeof pkgObj === \"string\" ? { name: pkgObj } : pkgObj;\n            location = pkgObj.location;\n\n            //Add dir to the path, but avoid paths that start with a slash\n            //or have a colon (indicates a protocol)\n            if (dir && (!location || (location.indexOf(\"/\") !== 0 && location.indexOf(\":\") === -1))) {\n                location = dir + \"/\" + (location || pkgObj.name);\n            }\n\n            //Create a brand new object on pkgs, since currentPackages can\n            //be passed in again, and config.pkgs is the internal transformed\n            //state for all package configs.\n            pkgs[pkgObj.name] = {\n                name: pkgObj.name,\n                location: location || pkgObj.name,\n                lib: pkgObj.lib || \"lib\",\n                //Remove leading dot in main, so main paths are normalized,\n                //and remove any trailing .js, since different package\n                //envs have different conventions: some use a module name,\n                //some use a file name.\n                main: (pkgObj.main || \"lib/main\")\n                      .replace(currDirRegExp, '')\n                      .replace(jsSuffixRegExp, '')\n            };\n        }\n    }\n\n    //Check for an existing version of require. If so, then exit out. Only allow\n    //one version of require to be active in a page. However, allow for a require\n    //config object, just exit quickly if require is an actual function.\n    if (typeof require !== \"undefined\") {\n        if (isFunction(require)) {\n            return;\n        } else {\n            //assume it is a config object.\n            cfg = require;\n        }\n    }\n\n    /**\n     * Creates a new context for use in require and define calls.\n     * Handle most of the heavy lifting. Do not want to use an object\n     * with prototype here to avoid using \"this\" in require, in case it\n     * needs to be used in more super secure envs that do not want this.\n     * Also there should not be that many contexts in the page. Usually just\n     * one for the default context, but could be extra for multiversion cases\n     * or if a package needs a special context for a dependency that conflicts\n     * with the standard context.\n     */\n    function newContext(contextName) {\n        var context, resume,\n            config = {\n                waitSeconds: 7,\n                baseUrl: s.baseUrl || \"./\",\n                paths: {},\n                pkgs: {}\n            },\n            defQueue = [],\n            specified = {\n                \"require\": true,\n                \"exports\": true,\n                \"module\": true\n            },\n            urlMap = {},\n            defined = {},\n            loaded = {},\n            waiting = {},\n            waitAry = [],\n            waitIdCounter = 0,\n            managerCallbacks = {},\n            plugins = {},\n            pluginsQueue = {},\n            resumeDepth = 0,\n            normalizedWaiting = {};\n\n        /**\n         * Trims the . and .. from an array of path segments.\n         * It will keep a leading path segment if a .. will become\n         * the first path segment, to help with module name lookups,\n         * which act like paths, but can be remapped. But the end result,\n         * all paths that use this function should look normalized.\n         * NOTE: this method MODIFIES the input array.\n         * @param {Array} ary the array of path segments.\n         */\n        function trimDots(ary) {\n            var i, part;\n            for (i = 0; (part = ary[i]); i++) {\n                if (part === \".\") {\n                    ary.splice(i, 1);\n                    i -= 1;\n                } else if (part === \"..\") {\n                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                        //End of the line. Keep at least one non-dot\n                        //path segment at the front so it can be mapped\n                        //correctly to disk. Otherwise, there is likely\n                        //no path mapping for a path starting with '..'.\n                        //This can still fail, but catches the most reasonable\n                        //uses of ..\n                        break;\n                    } else if (i > 0) {\n                        ary.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Given a relative module name, like ./something, normalize it to\n         * a real name that can be mapped to a path.\n         * @param {String} name the relative name\n         * @param {String} baseName a real name that the name arg is relative\n         * to.\n         * @returns {String} normalized name\n         */\n        function normalize(name, baseName) {\n            var pkgName, pkgConfig;\n\n            //Adjust any relative paths.\n            if (name.charAt(0) === \".\") {\n                //If have a base name, try to normalize against it,\n                //otherwise, assume it is a top-level require that will\n                //be relative to baseUrl in the end.\n                if (baseName) {\n                    if (config.pkgs[baseName]) {\n                        //If the baseName is a package name, then just treat it as one\n                        //name to concat the name with.\n                        baseName = [baseName];\n                    } else {\n                        //Convert baseName to array, and lop off the last part,\n                        //so that . matches that \"directory\" and not name of the baseName's\n                        //module. For instance, baseName of \"one/two/three\", maps to\n                        //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                        //this normalization.\n                        baseName = baseName.split(\"/\");\n                        baseName = baseName.slice(0, baseName.length - 1);\n                    }\n\n                    name = baseName.concat(name.split(\"/\"));\n                    trimDots(name);\n\n                    //Some use of packages may use a . path to reference the\n                    //\"main\" module name, so normalize for that.\n                    pkgConfig = config.pkgs[(pkgName = name[0])];\n                    name = name.join(\"/\");\n                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {\n                        name = pkgName;\n                    }\n                }\n            }\n            return name;\n        }\n\n        /**\n         * Creates a module mapping that includes plugin prefix, module\n         * name, and path. If parentModuleMap is provided it will\n         * also normalize the name via require.normalize()\n         *\n         * @param {String} name the module name\n         * @param {String} [parentModuleMap] parent module map\n         * for the module name, used to resolve relative names.\n         *\n         * @returns {Object}\n         */\n        function makeModuleMap(name, parentModuleMap) {\n            var index = name ? name.indexOf(\"!\") : -1,\n                prefix = null,\n                parentName = parentModuleMap ? parentModuleMap.name : null,\n                originalName = name,\n                normalizedName, url, pluginModule;\n\n            if (index !== -1) {\n                prefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n\n            if (prefix) {\n                prefix = normalize(prefix, parentName);\n                //Allow simpler mappings for some plugins\n                prefix = requirePlugins[prefix] || prefix;\n            }\n\n            //Account for relative paths if there is a base name.\n            if (name) {\n                if (prefix) {\n                    pluginModule = defined[prefix];\n                    if (pluginModule) {\n                        //Plugin is loaded, use its normalize method, otherwise,\n                        //normalize name as usual.\n                        if (pluginModule.normalize) {\n                            normalizedName = pluginModule.normalize(name, function (name) {\n                                return normalize(name, parentName);\n                            });\n                        } else {\n                            normalizedName = normalize(name, parentName);\n                        }\n                    } else {\n                        //Plugin is not loaded yet, so do not normalize\n                        //the name, wait for plugin to load to see if\n                        //it has a normalize method. To avoid possible\n                        //ambiguity with relative names loaded from another\n                        //plugin, use the parent's name as part of this name.\n                        normalizedName = '__$p' + parentName + '@' + name;\n                    }\n                } else {\n                    normalizedName = normalize(name, parentName);\n                }\n\n                url = urlMap[normalizedName];\n                if (!url) {\n                    //Calculate url for the module, if it has a name.\n                    if (req.toModuleUrl) {\n                        //Special logic required for a particular engine,\n                        //like Node.\n                        url = req.toModuleUrl(context, name, parentModuleMap);\n                    } else {\n                        url = context.nameToUrl(name, null, parentModuleMap);\n                    }\n\n                    //Store the URL mapping for later.\n                    urlMap[normalizedName] = url;\n                }\n            }\n\n            return {\n                prefix: prefix,\n                name: normalizedName,\n                parentMap: parentModuleMap,\n                url: url,\n                originalName: originalName,\n                fullName: prefix ? prefix + \"!\" + normalizedName : normalizedName\n            };\n        }\n\n        /**\n         * Determine if priority loading is done. If so clear the priorityWait\n         */\n        function isPriorityDone() {\n            var priorityDone = true,\n                priorityWait = config.priorityWait,\n                priorityName, i;\n            if (priorityWait) {\n                for (i = 0; (priorityName = priorityWait[i]); i++) {\n                    if (!loaded[priorityName]) {\n                        priorityDone = false;\n                        break;\n                    }\n                }\n                if (priorityDone) {\n                    delete config.priorityWait;\n                }\n            }\n            return priorityDone;\n        }\n\n        /**\n         * Helper function that creates a setExports function for a \"module\"\n         * CommonJS dependency. Do this here to avoid creating a closure that\n         * is part of a loop.\n         */\n        function makeSetExports(moduleObj) {\n            return function (exports) {\n                moduleObj.exports = exports;\n            };\n        }\n\n        function makeContextModuleFunc(func, relModuleMap, enableBuildCallback) {\n            return function () {\n                //A version of a require function that passes a moduleName\n                //value for items that may need to\n                //look up paths relative to the moduleName\n                var args = [].concat(aps.call(arguments, 0)), lastArg;\n                if (enableBuildCallback &&\n                    isFunction((lastArg = args[args.length - 1]))) {\n                    lastArg.__requireJsBuild = true;\n                }\n                args.push(relModuleMap);\n                return func.apply(null, args);\n            };\n        }\n\n        /**\n         * Helper function that creates a require function object to give to\n         * modules that ask for it as a dependency. It needs to be specific\n         * per module because of the implication of path mappings that may\n         * need to be relative to the module name.\n         */\n        function makeRequire(relModuleMap, enableBuildCallback) {\n            var modRequire = makeContextModuleFunc(context.require, relModuleMap, enableBuildCallback);\n\n            mixin(modRequire, {\n                nameToUrl: makeContextModuleFunc(context.nameToUrl, relModuleMap),\n                toUrl: makeContextModuleFunc(context.toUrl, relModuleMap),\n                isDefined: makeContextModuleFunc(context.isDefined, relModuleMap),\n                ready: req.ready,\n                isBrowser: req.isBrowser\n            });\n            //Something used by node.\n            if (req.paths) {\n                modRequire.paths = req.paths;\n            }\n            return modRequire;\n        }\n\n        /**\n         * Used to update the normalized name for plugin-based dependencies\n         * after a plugin loads, since it can have its own normalization structure.\n         * @param {String} pluginName the normalized plugin module name.\n         */\n        function updateNormalizedNames(pluginName) {\n\n            var oldFullName, oldModuleMap, moduleMap, fullName, callbacks,\n                i, j, k, depArray, existingCallbacks,\n                maps = normalizedWaiting[pluginName];\n\n            if (maps) {\n                for (i = 0; (oldModuleMap = maps[i]); i++) {\n                    oldFullName = oldModuleMap.fullName;\n                    moduleMap = makeModuleMap(oldModuleMap.originalName, oldModuleMap.parentMap);\n                    fullName = moduleMap.fullName;\n                    callbacks = managerCallbacks[oldFullName];\n                    existingCallbacks = managerCallbacks[fullName];\n\n                    if (fullName !== oldFullName) {\n                        //Update the specified object, but only if it is already\n                        //in there. In sync environments, it may not be yet.\n                        if (oldFullName in specified) {\n                            delete specified[oldFullName];\n                            specified[fullName] = true;\n                        }\n\n                        //Update managerCallbacks to use the correct normalized name.\n                        //If there are already callbacks for the normalized name,\n                        //just add to them.\n                        if (existingCallbacks) {\n                            managerCallbacks[fullName] = existingCallbacks.concat(callbacks);\n                        } else {\n                            managerCallbacks[fullName] = callbacks;\n                        }\n                        delete managerCallbacks[oldFullName];\n\n                        //In each manager callback, update the normalized name in the depArray.\n                        for (j = 0; j < callbacks.length; j++) {\n                            depArray = callbacks[j].depArray;\n                            for (k = 0; k < depArray.length; k++) {\n                                if (depArray[k] === oldFullName) {\n                                    depArray[k] = fullName;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            delete normalizedWaiting[pluginName];\n        }\n\n        /*\n         * Queues a dependency for checking after the loader is out of a\n         * \"paused\" state, for example while a script file is being loaded\n         * in the browser, where it may have many modules defined in it.\n         *\n         * depName will be fully qualified, no relative . or .. path.\n         */\n        function queueDependency(dep) {\n            //Make sure to load any plugin and associate the dependency\n            //with that plugin.\n            var prefix = dep.prefix,\n                fullName = dep.fullName;\n\n            //Do not bother if the depName is already in transit\n            if (specified[fullName] || fullName in defined) {\n                return;\n            }\n\n            if (prefix && !plugins[prefix]) {\n                //Queue up loading of the dependency, track it\n                //via context.plugins. Mark it as a plugin so\n                //that the build system will know to treat it\n                //special.\n                plugins[prefix] = undefined;\n\n                //Remember this dep that needs to have normaliztion done\n                //after the plugin loads.\n                (normalizedWaiting[prefix] || (normalizedWaiting[prefix] = []))\n                    .push(dep);\n\n                //Register an action to do once the plugin loads, to update\n                //all managerCallbacks to use a properly normalized module\n                //name.\n                (managerCallbacks[prefix] ||\n                (managerCallbacks[prefix] = [])).push({\n                    onDep: function (name, value) {\n                        if (name === prefix) {\n                            updateNormalizedNames(prefix);\n                        }\n                    }\n                });\n\n                queueDependency(makeModuleMap(prefix));\n            }\n\n            context.paused.push(dep);\n        }\n\n        function execManager(manager) {\n            var i, ret, waitingCallbacks,\n                cb = manager.callback,\n                fullName = manager.fullName,\n                args = [],\n                ary = manager.depArray;\n\n            //Call the callback to define the module, if necessary.\n            if (cb && isFunction(cb)) {\n                //Pull out the defined dependencies and pass the ordered\n                //values to the callback.\n                if (ary) {\n                    for (i = 0; i < ary.length; i++) {\n                        args.push(manager.deps[ary[i]]);\n                    }\n                }\n\n                ret = req.execCb(fullName, manager.callback, args);\n\n                if (fullName) {\n                    //If using exports and the function did not return a value,\n                    //and the \"module\" object for this definition function did not\n                    //define an exported value, then use the exports object.\n                    if (manager.usingExports && ret === undefined && (!manager.cjsModule || !(\"exports\" in manager.cjsModule))) {\n                        ret = defined[fullName];\n                    } else {\n                        if (manager.cjsModule && \"exports\" in manager.cjsModule) {\n                            ret = defined[fullName] = manager.cjsModule.exports;\n                        } else {\n                            if (fullName in defined && !manager.usingExports) {\n                                return req.onError(new Error(fullName + \" has already been defined\"));\n                            }\n                            defined[fullName] = ret;\n                        }\n                    }\n                }\n            } else if (fullName) {\n                //May just be an object definition for the module. Only\n                //worry about defining if have a module name.\n                ret = defined[fullName] = cb;\n            }\n\n            if (fullName) {\n                //If anything was waiting for this module to be defined,\n                //notify them now.\n                waitingCallbacks = managerCallbacks[fullName];\n                if (waitingCallbacks) {\n                    for (i = 0; i < waitingCallbacks.length; i++) {\n                        waitingCallbacks[i].onDep(fullName, ret);\n                    }\n                    delete managerCallbacks[fullName];\n                }\n            }\n\n            //Clean up waiting.\n            if (waiting[manager.waitId]) {\n                delete waiting[manager.waitId];\n                manager.isDone = true;\n                context.waitCount -= 1;\n                if (context.waitCount === 0) {\n                    //Clear the wait array used for cycles.\n                    waitAry = [];\n                }\n            }\n\n            return undefined;\n        }\n\n        function main(inName, depArray, callback, relModuleMap) {\n            var moduleMap = makeModuleMap(inName, relModuleMap),\n                name = moduleMap.name,\n                fullName = moduleMap.fullName,\n                uniques = {},\n                manager = {\n                    //Use a wait ID because some entries are anon\n                    //async require calls.\n                    waitId: name || reqWaitIdPrefix + (waitIdCounter++),\n                    depCount: 0,\n                    depMax: 0,\n                    prefix: moduleMap.prefix,\n                    name: name,\n                    fullName: fullName,\n                    deps: {},\n                    depArray: depArray,\n                    callback: callback,\n                    onDep: function (depName, value) {\n                        if (!(depName in manager.deps)) {\n                            manager.deps[depName] = value;\n                            manager.depCount += 1;\n                            if (manager.depCount === manager.depMax) {\n                                //All done, execute!\n                                execManager(manager);\n                            }\n                        }\n                    }\n                },\n                i, depArg, depName, cjsMod;\n\n            if (fullName) {\n                //If module already defined for context, or already loaded,\n                //then leave.\n                if (fullName in defined || loaded[fullName] === true) {\n                    return;\n                }\n\n                //Set specified/loaded here for modules that are also loaded\n                //as part of a layer, where onScriptLoad is not fired\n                //for those cases. Do this after the inline define and\n                //dependency tracing is done.\n                //Also check if auto-registry of jQuery needs to be skipped.\n                specified[fullName] = true;\n                loaded[fullName] = true;\n                context.jQueryDef = (fullName === \"jquery\");\n            }\n\n            //Add the dependencies to the deps field, and register for callbacks\n            //on the dependencies.\n            for (i = 0; i < depArray.length; i++) {\n                depArg = depArray[i];\n                //There could be cases like in IE, where a trailing comma will\n                //introduce a null dependency, so only treat a real dependency\n                //value as a dependency.\n                if (depArg) {\n                    //Split the dependency name into plugin and name parts\n                    depArg = makeModuleMap(depArg, (name ? moduleMap : relModuleMap));\n                    depName = depArg.fullName;\n\n                    //Fix the name in depArray to be just the name, since\n                    //that is how it will be called back later.\n                    depArray[i] = depName;\n\n                    //Fast path CommonJS standard dependencies.\n                    if (depName === \"require\") {\n                        manager.deps[depName] = makeRequire(moduleMap);\n                    } else if (depName === \"exports\") {\n                        //CommonJS module spec 1.1\n                        manager.deps[depName] = defined[fullName] = {};\n                        manager.usingExports = true;\n                    } else if (depName === \"module\") {\n                        //CommonJS module spec 1.1\n                        manager.cjsModule = cjsMod = manager.deps[depName] = {\n                            id: name,\n                            uri: name ? context.nameToUrl(name, null, relModuleMap) : undefined\n                        };\n                        cjsMod.setExports = makeSetExports(cjsMod);\n                    } else if (depName in defined && !(depName in waiting)) {\n                        //Module already defined, no need to wait for it.\n                        manager.deps[depName] = defined[depName];\n                    } else if (!uniques[depName]) {\n\n                        //A dynamic dependency.\n                        manager.depMax += 1;\n\n                        queueDependency(depArg);\n\n                        //Register to get notification when dependency loads.\n                        (managerCallbacks[depName] ||\n                        (managerCallbacks[depName] = [])).push(manager);\n\n                        uniques[depName] = true;\n                    }\n                }\n            }\n\n            //Do not bother tracking the manager if it is all done.\n            if (manager.depCount === manager.depMax) {\n                //All done, execute!\n                execManager(manager);\n            } else {\n                waiting[manager.waitId] = manager;\n                waitAry.push(manager);\n                context.waitCount += 1;\n            }\n        }\n\n        /**\n         * Convenience method to call main for a require.def call that was put on\n         * hold in the defQueue.\n         */\n        function callDefMain(args) {\n            main.apply(null, args);\n            //Mark the module loaded. Must do it here in addition\n            //to doing it in require.def in case a script does\n            //not call require.def\n            loaded[args[0]] = true;\n        }\n\n        /**\n         * As of jQuery 1.4.3, it supports a readyWait property that will hold off\n         * calling jQuery ready callbacks until all scripts are loaded. Be sure\n         * to track it if readyWait is available. Also, since jQuery 1.4.3 does\n         * not register as a module, need to do some global inference checking.\n         * Even if it does register as a module, not guaranteed to be the precise\n         * name of the global. If a jQuery is tracked for this context, then go\n         * ahead and register it as a module too, if not already in process.\n         */\n        function jQueryCheck(jqCandidate) {\n            if (!context.jQuery) {\n                var $ = jqCandidate || (typeof jQuery !== \"undefined\" ? jQuery : null);\n                if ($ && \"readyWait\" in $) {\n                    context.jQuery = $;\n\n                    //Manually create a \"jquery\" module entry if not one already\n                    //or in process.\n                    callDefMain([\"jquery\", [], function () {\n                        return jQuery;\n                    }]);\n\n                    //Increment jQuery readyWait if ncecessary.\n                    if (context.scriptCount) {\n                        $.readyWait += 1;\n                        context.jQueryIncremented = true;\n                    }\n                }\n            }\n        }\n\n        function forceExec(manager, traced) {\n            if (manager.isDone) {\n                return undefined;\n            }\n\n            var fullName = manager.fullName,\n                depArray = manager.depArray,\n                depName, i;\n            if (fullName) {\n                if (traced[fullName]) {\n                    return defined[fullName];\n                }\n\n                traced[fullName] = true;\n            }\n\n            //forceExec all of its dependencies.\n            for (i = 0; i < depArray.length; i++) {\n                //Some array members may be null, like if a trailing comma\n                //IE, so do the explicit [i] access and check if it has a value.\n                depName = depArray[i];\n                if (depName) {\n                    if (!manager.deps[depName] && waiting[depName]) {\n                        manager.onDep(depName, forceExec(waiting[depName], traced));\n                    }\n                }\n            }\n\n            return fullName ? defined[fullName] : undefined;\n        }\n\n        /**\n         * Checks if all modules for a context are loaded, and if so, evaluates the\n         * new ones in right dependency order.\n         *\n         * @private\n         */\n        function checkLoaded() {\n            var waitInterval = config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                noLoads = \"\", hasLoadedProp = false, stillLoading = false, prop,\n                err, manager;\n\n            //If there are items still in the paused queue processing wait.\n            //This is particularly important in the sync case where each paused\n            //item is processed right away but there may be more waiting.\n            if (context.pausedCount > 0) {\n                return undefined;\n            }\n\n            //Determine if priority loading is done. If so clear the priority. If\n            //not, then do not check\n            if (config.priorityWait) {\n                if (isPriorityDone()) {\n                    //Call resume, since it could have\n                    //some waiting dependencies to trace.\n                    resume();\n                } else {\n                    return undefined;\n                }\n            }\n\n            //See if anything is still in flight.\n            for (prop in loaded) {\n                if (!(prop in empty)) {\n                    hasLoadedProp = true;\n                    if (!loaded[prop]) {\n                        if (expired) {\n                            noLoads += prop + \" \";\n                        } else {\n                            stillLoading = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            //Check for exit conditions.\n            if (!hasLoadedProp && !context.waitCount) {\n                //If the loaded object had no items, then the rest of\n                //the work below does not need to be done.\n                return undefined;\n            }\n            if (expired && noLoads) {\n                //If wait time expired, throw error of unloaded modules.\n                err = new Error(\"require.js load timeout for modules: \" + noLoads);\n                err.requireType = \"timeout\";\n                err.requireModules = noLoads;\n                return req.onError(err);\n            }\n            if (stillLoading || context.scriptCount) {\n                //Something is still waiting to load. Wait for it.\n                if (isBrowser || isWebWorker) {\n                    setTimeout(checkLoaded, 50);\n                }\n                return undefined;\n            }\n\n            //If still have items in the waiting cue, but all modules have\n            //been loaded, then it means there are some circular dependencies\n            //that need to be broken.\n            //However, as a waiting thing is fired, then it can add items to\n            //the waiting cue, and those items should not be fired yet, so\n            //make sure to redo the checkLoaded call after breaking a single\n            //cycle, if nothing else loaded then this logic will pick it up\n            //again.\n            if (context.waitCount) {\n                //Cycle through the waitAry, and call items in sequence.\n                for (i = 0; (manager = waitAry[i]); i++) {\n                    forceExec(manager, {});\n                }\n\n                checkLoaded();\n                return undefined;\n            }\n\n            //Check for DOM ready, and nothing is waiting across contexts.\n            req.checkReadyState();\n\n            return undefined;\n        }\n\n        function callPlugin(pluginName, dep) {\n            var name = dep.name,\n                fullName = dep.fullName;\n\n            //Do not bother if plugin is already defined or being loaded.\n            if (fullName in defined || fullName in loaded) {\n                return;\n            }\n\n            if (!plugins[pluginName]) {\n                plugins[pluginName] = defined[pluginName];\n            }\n\n            //Only set loaded to false for tracking if it has not already been set.\n            if (!loaded[fullName]) {\n                loaded[fullName] = false;\n            }\n\n            //Use parentName here since the plugin's name is not reliable,\n            //could be some weird string with no path that actually wants to\n            //reference the parentName's path.\n            plugins[pluginName].load(name, makeRequire(dep.parentMap, true), function (ret) {\n                //Allow the build process to register plugin-loaded dependencies.\n                if (require.onPluginLoad) {\n                    require.onPluginLoad(context, pluginName, name, ret);\n                }\n\n                execManager({\n                    prefix: dep.prefix,\n                    name: dep.name,\n                    fullName: dep.fullName,\n                    callback: function () {\n                        return ret;\n                    }\n                });\n                loaded[fullName] = true;\n            }, config);\n        }\n\n        function loadPaused(dep) {\n            //Renormalize dependency if its name was waiting on a plugin\n            //to load, which as since loaded.\n            if (dep.prefix && dep.name.indexOf('__$p') === 0 && defined[dep.prefix]) {\n                dep = makeModuleMap(dep.originalName, dep.parentMap);\n            }\n\n            var pluginName = dep.prefix,\n                fullName = dep.fullName;\n\n            //Do not bother if the dependency has already been specified.\n            if (specified[fullName] || fullName in defined) {\n                return;\n            } else {\n                specified[fullName] = true;\n            }\n\n            if (pluginName) {\n                //If plugin not loaded, wait for it.\n                //set up callback list. if no list, then register\n                //managerCallback for that plugin.\n                if (defined[pluginName]) {\n                    callPlugin(pluginName, dep);\n                } else {\n                    if (!pluginsQueue[pluginName]) {\n                        pluginsQueue[pluginName] = [];\n                        (managerCallbacks[pluginName] ||\n                        (managerCallbacks[pluginName] = [])).push({\n                            onDep: function (name, value) {\n                                if (name === pluginName) {\n                                    var i, oldModuleMap, ary = pluginsQueue[pluginName];\n\n                                    //Now update all queued plugin actions.\n                                    for (i = 0; i < ary.length; i++) {\n                                        oldModuleMap = ary[i];\n                                        //Update the moduleMap since the\n                                        //module name may be normalized\n                                        //differently now.\n                                        callPlugin(pluginName,\n                                                   makeModuleMap(oldModuleMap.originalName, oldModuleMap.parentMap));\n                                    }\n                                    delete pluginsQueue[pluginName];\n                                }\n                            }\n                        });\n                    }\n                    pluginsQueue[pluginName].push(dep);\n                }\n            } else {\n                req.load(context, fullName, dep.url);\n            }\n        }\n\n        /**\n         * Resumes tracing of dependencies and then checks if everything is loaded.\n         */\n        resume = function () {\n            var args, i, p;\n\n            resumeDepth += 1;\n\n            if (context.scriptCount <= 0) {\n                //Synchronous envs will push the number below zero with the\n                //decrement above, be sure to set it back to zero for good measure.\n                //require() calls that also do not end up loading scripts could\n                //push the number negative too.\n                context.scriptCount = 0;\n            }\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    return req.onError(new Error('Mismatched anonymous require.def modules'));\n                } else {\n                    callDefMain(args);\n                }\n            }\n\n            //Skip the resume if current context is in priority wait.\n            if (config.priorityWait && !isPriorityDone()) {\n                return undefined;\n            }\n\n            while (context.paused.length) {\n                p = context.paused;\n                context.pausedCount += p.length;\n                //Reset paused list\n                context.paused = [];\n\n                for (i = 0; (args = p[i]); i++) {\n                    loadPaused(args);\n                }\n                //Move the start time for timeout forward.\n                context.startTime = (new Date()).getTime();\n                context.pausedCount -= p.length;\n            }\n\n            //Only check if loaded when resume depth is 1. It is likely that\n            //it is only greater than 1 in sync environments where a factory\n            //function also then calls the callback-style require. In those\n            //cases, the checkLoaded should not occur until the resume\n            //depth is back at the top level.\n            if (resumeDepth === 1) {\n                checkLoaded();\n            }\n\n            resumeDepth -= 1;\n\n            return undefined;\n        };\n\n        //Define the context object. Many of these fields are on here\n        //just to make debugging easier.\n        context = {\n            contextName: contextName,\n            config: config,\n            defQueue: defQueue,\n            waiting: waiting,\n            waitCount: 0,\n            specified: specified,\n            loaded: loaded,\n            urlMap: urlMap,\n            scriptCount: 0,\n            urlFetched: {},\n            defined: defined,\n            paused: [],\n            pausedCount: 0,\n            plugins: plugins,\n            managerCallbacks: managerCallbacks,\n            makeModuleMap: makeModuleMap,\n            normalize: normalize,\n            /**\n             * Set a configuration for the context.\n             * @param {Object} cfg config object to integrate.\n             */\n            configure: function (cfg) {\n                var paths, prop, packages, pkgs, packagePaths, requireWait;\n\n                //Make sure the baseUrl ends in a slash.\n                if (cfg.baseUrl) {\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== \"/\") {\n                        cfg.baseUrl += \"/\";\n                    }\n                }\n\n                //Save off the paths and packages since they require special processing,\n                //they are additive.\n                paths = config.paths;\n                packages = config.packages;\n                pkgs = config.pkgs;\n\n                //Mix in the config values, favoring the new values over\n                //existing ones in context.config.\n                mixin(config, cfg, true);\n\n                //Adjust paths if necessary.\n                if (cfg.paths) {\n                    for (prop in cfg.paths) {\n                        if (!(prop in empty)) {\n                            paths[prop] = cfg.paths[prop];\n                        }\n                    }\n                    config.paths = paths;\n                }\n\n                packagePaths = cfg.packagePaths;\n                if (packagePaths || cfg.packages) {\n                    //Convert packagePaths into a packages config.\n                    if (packagePaths) {\n                        for (prop in packagePaths) {\n                            if (!(prop in empty)) {\n                                configurePackageDir(pkgs, packagePaths[prop], prop);\n                            }\n                        }\n                    }\n\n                    //Adjust packages if necessary.\n                    if (cfg.packages) {\n                        configurePackageDir(pkgs, cfg.packages);\n                    }\n\n                    //Done with modifications, assing packages back to context config\n                    config.pkgs = pkgs;\n                }\n\n                //If priority loading is in effect, trigger the loads now\n                if (cfg.priority) {\n                    //Create a separate config property that can be\n                    //easily tested for config priority completion.\n                    //Do this instead of wiping out the config.priority\n                    //in case it needs to be inspected for debug purposes later.\n                    //Hold on to requireWait value, and reset it after done\n                    requireWait = context.requireWait;\n                    context.requireWait = false;\n                    context.require(cfg.priority);\n                    //Trigger a resume right away, for the case when\n                    //the script with the priority load is done as part\n                    //of a data-main call. In that case the normal resume\n                    //call will not happen because the scriptCount will be\n                    //at 1, since the script for data-main is being processed.\n                    resume();\n                    //Restore previous state.\n                    context.requireWait = requireWait;\n                    config.priorityWait = cfg.priority;\n                }\n\n                //If a deps array or a config callback is specified, then call\n                //require with those args. This is useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.deps || cfg.callback) {\n                    context.require(cfg.deps || [], cfg.callback);\n                }\n\n                //Set up ready callback, if asked. Useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.ready) {\n                    req.ready(cfg.ready);\n                }\n            },\n\n            isDefined: function (moduleName, relModuleMap) {\n                return makeModuleMap(moduleName, relModuleMap).fullName in defined;\n            },\n\n            require: function (deps, callback, relModuleMap) {\n                var moduleName, ret, moduleMap;\n                if (typeof deps === \"string\") {\n                    //Synchronous access to one module. If require.get is\n                    //available (as in the Node adapter), prefer that.\n                    //In this case deps is the moduleName and callback is\n                    //the relModuleMap\n                    if (req.get) {\n                        return req.get(context, deps, callback);\n                    }\n\n                    //Just return the module wanted. In this scenario, the\n                    //second arg (if passed) is just the relModuleMap.\n                    moduleName = deps;\n                    relModuleMap = callback;\n\n                    //Normalize module name, if it contains . or ..\n                    moduleMap = makeModuleMap(moduleName, relModuleMap);\n\n                    ret = defined[moduleMap.fullName];\n                    if (ret === undefined) {\n                        return req.onError(new Error(\"require: module name '\" +\n                                    moduleMap.fullName +\n                                    \"' has not been loaded yet for context: \" +\n                                    contextName));\n                    }\n                    return ret;\n                }\n\n                main(null, deps, callback, relModuleMap);\n\n                //If the require call does not trigger anything new to load,\n                //then resume the dependency processing.\n                if (!context.requireWait) {\n                    while (!context.scriptCount && context.paused.length) {\n                        resume();\n                    }\n                }\n                return undefined;\n            },\n\n            /**\n             * Internal method to transfer globalQueue items to this context's\n             * defQueue.\n             */\n            takeGlobalQueue: function () {\n                //Push all the globalDefQueue items into the context's defQueue\n                if (globalDefQueue.length) {\n                    //Array splice in the values since the context code has a\n                    //local var ref to defQueue, so cannot just reassign the one\n                    //on context.\n                    apsp.apply(context.defQueue,\n                               [context.defQueue.length - 1, 0].concat(globalDefQueue));\n                    globalDefQueue = [];\n                }\n            },\n\n            /**\n             * Internal method used by environment adapters to complete a load event.\n             * A load event could be a script load or just a load pass from a synchronous\n             * load call.\n             * @param {String} moduleName the name of the module to potentially complete.\n             */\n            completeLoad: function (moduleName) {\n                var args;\n\n                context.takeGlobalQueue();\n\n                while (defQueue.length) {\n                    args = defQueue.shift();\n\n                    if (args[0] === null) {\n                        args[0] = moduleName;\n                        break;\n                    } else if (args[0] === moduleName) {\n                        //Found matching require.def call for this script!\n                        break;\n                    } else {\n                        //Some other named require.def call, most likely the result\n                        //of a build layer that included many require.def calls.\n                        callDefMain(args);\n                        args = null;\n                    }\n                }\n                if (args) {\n                    callDefMain(args);\n                } else {\n                    //A script that does not call define(), so just simulate\n                    //the call for it. Special exception for jQuery dynamic load.\n                    callDefMain([moduleName, [],\n                                moduleName === \"jquery\" && typeof jQuery !== \"undefined\" ?\n                                function () {\n                                    return jQuery;\n                                } : null]);\n                }\n\n                //Mark the script as loaded. Note that this can be different from a\n                //moduleName that maps to a require.def call. This line is important\n                //for traditional browser scripts.\n                loaded[moduleName] = true;\n\n                //If a global jQuery is defined, check for it. Need to do it here\n                //instead of main() since stock jQuery does not register as\n                //a module via define.\n                jQueryCheck();\n\n                //Doing this scriptCount decrement branching because sync envs\n                //need to decrement after resume, otherwise it looks like\n                //loading is complete after the first dependency is fetched.\n                //For browsers, it works fine to decrement after, but it means\n                //the checkLoaded setTimeout 50 ms cost is taken. To avoid\n                //that cost, decrement beforehand.\n                if (req.isAsync) {\n                    context.scriptCount -= 1;\n                }\n                resume();\n                if (!req.isAsync) {\n                    context.scriptCount -= 1;\n                }\n            },\n\n            /**\n             * Converts a module name + .extension into an URL path.\n             * *Requires* the use of a module name. It does not support using\n             * plain URLs like nameToUrl.\n             */\n            toUrl: function (moduleNamePlusExt, relModuleMap) {\n                var index = moduleNamePlusExt.lastIndexOf(\".\"),\n                    ext = null;\n\n                if (index !== -1) {\n                    ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n                    moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n                }\n\n                return context.nameToUrl(moduleNamePlusExt, ext, relModuleMap);\n            },\n\n            /**\n             * Converts a module name to a file path. Supports cases where\n             * moduleName may actually be just an URL.\n             */\n            nameToUrl: function (moduleName, ext, relModuleMap) {\n                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,\n                    config = context.config;\n\n                if (moduleName.indexOf(\"./\") === 0 || moduleName.indexOf(\"../\") === 0) {\n                    //A relative ID, just map it relative to relModuleMap's url\n                    syms = relModuleMap && relModuleMap.url ? relModuleMap.url.split('/') : [];\n                    //Pop off the file name.\n                    if (syms.length) {\n                        syms.pop();\n                    }\n                    syms = syms.concat(moduleName.split('/'));\n                    trimDots(syms);\n                    url = syms.join('/') +\n                          (ext ? ext :\n                          (req.jsExtRegExp.test(moduleName) ? \"\" : \".js\"));\n                } else {\n\n                    //Normalize module name if have a base relative module name to work from.\n                    moduleName = normalize(moduleName, relModuleMap);\n\n                    //If a colon is in the URL, it indicates a protocol is used and it is just\n                    //an URL to a file, or if it starts with a slash or ends with .js, it is just a plain file.\n                    //The slash is important for protocol-less URLs as well as full paths.\n                    if (req.jsExtRegExp.test(moduleName)) {\n                        //Just a plain path, not module name lookup, so just return it.\n                        //Add extension if it is included. This is a bit wonky, only non-.js things pass\n                        //an extension, this method probably needs to be reworked.\n                        url = moduleName + (ext ? ext : \"\");\n                    } else {\n                        //A module that needs to be converted to a path.\n                        paths = config.paths;\n                        pkgs = config.pkgs;\n\n                        syms = moduleName.split(\"/\");\n                        //For each module name segment, see if there is a path\n                        //registered for it. Start with most specific name\n                        //and work up from it.\n                        for (i = syms.length; i > 0; i--) {\n                            parentModule = syms.slice(0, i).join(\"/\");\n                            if (paths[parentModule]) {\n                                syms.splice(0, i, paths[parentModule]);\n                                break;\n                            } else if ((pkg = pkgs[parentModule])) {\n                                //If module name is just the package name, then looking\n                                //for the main module.\n                                if (moduleName === pkg.name) {\n                                    pkgPath = pkg.location + '/' + pkg.main;\n                                } else {\n                                    pkgPath = pkg.location + '/' + pkg.lib;\n                                }\n                                syms.splice(0, i, pkgPath);\n                                break;\n                            }\n                        }\n\n                        //Join the path parts together, then figure out if baseUrl is needed.\n                        url = syms.join(\"/\") + (ext || \".js\");\n                        url = (url.charAt(0) === '/' || url.match(/^\\w+:/) ? \"\" : config.baseUrl) + url;\n                    }\n                }\n\n                return config.urlArgs ? url +\n                                        ((url.indexOf('?') === -1 ? '?' : '&') +\n                                         config.urlArgs) : url;\n            }\n        };\n\n        //Make these visible on the context so can be called at the very\n        //end of the file to bootstrap\n        context.jQueryCheck = jQueryCheck;\n        context.resume = resume;\n\n        return context;\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     *\n     * Make a local req variable to help Caja compliance (it assumes things\n     * on a require that are not standardized), and to give a short\n     * name for minification/local scope use.\n     */\n    req = require = function (deps, callback) {\n\n        //Find the right context, use default\n        var contextName = defContextName,\n            context, config;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== \"string\") {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = arguments[2];\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n\n        context = contexts[contextName] ||\n                  (contexts[contextName] = newContext(contextName));\n\n        if (config) {\n            context.configure(config);\n        }\n\n        return context.require(deps, callback);\n    };\n\n    req.version = version;\n    req.isArray = isArray;\n    req.isFunction = isFunction;\n    req.mixin = mixin;\n    //Used to filter out dependencies that are already paths.\n    req.jsExtRegExp = /^\\/|:|\\?|\\.js$/;\n    s = req.s = {\n        contexts: contexts,\n        //Stores a list of URLs that should not get async script tag treatment.\n        skipAsync: {},\n        isPageLoaded: !isBrowser,\n        readyCalls: []\n    };\n\n    req.isAsync = req.isBrowser = isBrowser;\n    if (isBrowser) {\n        head = s.head = document.getElementsByTagName(\"head\")[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName(\"base\")[0];\n        if (baseElement) {\n            head = s.head = baseElement.parentNode;\n        }\n    }\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * @param {Error} err the error object.\n     */\n    req.onError = function (err) {\n        throw err;\n    };\n\n    /**\n     * Does the request to load a module for the browser case.\n     * Make this a separate function to allow other environments\n     * to override it.\n     *\n     * @param {Object} context the require context to find state.\n     * @param {String} moduleName the name of the module.\n     * @param {Object} url the URL to the module.\n     */\n    req.load = function (context, moduleName, url) {\n        var contextName = context.contextName,\n            urlFetched = context.urlFetched,\n            loaded = context.loaded;\n        isDone = false;\n\n        //Only set loaded to false for tracking if it has not already been set.\n        if (!loaded[moduleName]) {\n            loaded[moduleName] = false;\n        }\n\n        if (!urlFetched[url]) {\n            context.scriptCount += 1;\n            req.attach(url, contextName, moduleName);\n            urlFetched[url] = true;\n\n            //If tracking a jQuery, then make sure its readyWait\n            //is incremented to prevent its ready callbacks from\n            //triggering too soon.\n            if (context.jQuery && !context.jQueryIncremented) {\n                context.jQuery.readyWait += 1;\n                context.jQueryIncremented = true;\n            }\n        }\n    };\n\n    function getInteractiveScript() {\n        var scripts, i, script;\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\n            return interactiveScript;\n        }\n\n        scripts = document.getElementsByTagName('script');\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            if (script.readyState === 'interactive') {\n                return (interactiveScript = script);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument's\n     * name.\n     */\n    define = req.def = function (name, deps, callback) {\n        var node, context;\n\n        //Allow for anonymous functions\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!req.isArray(deps)) {\n            callback = deps;\n            deps = [];\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!name && !deps.length && req.isFunction(callback)) {\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies,\n            //but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, \"\")\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and such, so always add those as dependencies.\n                //This is a bit wasteful for RequireJS modules that do not need\n                //an exports or module object, but erring on side of safety.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = [\"require\", \"exports\", \"module\"].concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (!node) {\n                return req.onError(new Error(\"ERROR: No matching script interactive for \" + callback));\n            }\n            if (!name) {\n                name = node.getAttribute(\"data-requiremodule\");\n            }\n            context = contexts[node.getAttribute(\"data-requirecontext\")];\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n\n        return undefined;\n    };\n\n    define.amd = {\n        multiversion: true,\n        plugins: true\n    };\n\n    /**\n     * Executes a module callack function. Broken out as a separate function\n     * solely to allow the build system to sequence the files in the built\n     * layer in the right sequence.\n     *\n     * @private\n     */\n    req.execCb = function (name, callback, args) {\n        return callback.apply(null, args);\n    };\n\n    /**\n     * callback for script loads, used to check status of loading.\n     *\n     * @param {Event} evt the event from the browser for the script\n     * that was loaded.\n     *\n     * @private\n     */\n    req.onScriptLoad = function (evt) {\n        //Using currentTarget instead of target for Firefox 2.0's sake. Not\n        //all old browsers will be supported, but this one was easy enough\n        //to support and still makes sense.\n        var node = evt.currentTarget || evt.srcElement, contextName, moduleName,\n            context;\n\n        if (evt.type === \"load\" || readyRegExp.test(node.readyState)) {\n            //Reset interactive script so a script node is not held onto for\n            //to long.\n            interactiveScript = null;\n\n            //Pull out the name of the module and the context.\n            contextName = node.getAttribute(\"data-requirecontext\");\n            moduleName = node.getAttribute(\"data-requiremodule\");\n            context = contexts[contextName];\n\n            contexts[contextName].completeLoad(moduleName);\n\n            //Clean up script binding.\n            if (node.removeEventListener) {\n                node.removeEventListener(\"load\", req.onScriptLoad, false);\n            } else {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                node.detachEvent(\"onreadystatechange\", req.onScriptLoad);\n            }\n        }\n    };\n\n    /**\n     * Attaches the script represented by the URL to the current\n     * environment. Right now only supports browser loading,\n     * but can be redefined in other environments to do the right thing.\n     * @param {String} url the url of the script to attach.\n     * @param {String} contextName the name of the context that wants the script.\n     * @param {moduleName} the name of the module that is associated with the script.\n     * @param {Function} [callback] optional callback, defaults to require.onScriptLoad\n     * @param {String} [type] optional type, defaults to text/javascript\n     */\n    req.attach = function (url, contextName, moduleName, callback, type) {\n        var node, loaded, context;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            callback = callback || req.onScriptLoad;\n            node = document.createElement(\"script\");\n            node.type = type || \"text/javascript\";\n            node.charset = \"utf-8\";\n            //Use async so Gecko does not block on executing the script if something\n            //like a long-polling comet tag is being run first. Gecko likes\n            //to evaluate scripts in DOM order, even for dynamic scripts.\n            //It will fetch them async, but only evaluate the contents in DOM\n            //order, so a long-polling script tag can delay execution of scripts\n            //after it. But telling Gecko we expect async gets us the behavior\n            //we want -- execute it whenever it is finished downloading. Only\n            //Helps Firefox 3.6+\n            //Allow some URLs to not be fetched async. Mostly helps the order!\n            //plugin\n            node.async = !s.skipAsync[url];\n\n            node.setAttribute(\"data-requirecontext\", contextName);\n            node.setAttribute(\"data-requiremodule\", moduleName);\n\n            //Set up load listener.\n            if (node.addEventListener) {\n                node.addEventListener(\"load\", callback, false);\n            } else {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous require.def call to a name.\n                //However, IE reports the script as being in \"interactive\"\n                //readyState at the time of the require.def call.\n                useInteractive = true;\n                node.attachEvent(\"onreadystatechange\", callback);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous require.def\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                head.insertBefore(node, baseElement);\n            } else {\n                head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n            return node;\n        } else if (isWebWorker) {\n            //In a web worker, use importScripts. This is not a very\n            //efficient use of importScripts, importScripts will block until\n            //its script is downloaded and evaluated. However, if web workers\n            //are in play, the expectation that a build has been done so that\n            //only one script needs to be loaded anyway. This may need to be\n            //reevaluated if other use cases become common.\n            context = contexts[contextName];\n            loaded = context.loaded;\n            loaded[moduleName] = false;\n\n            importScripts(url);\n\n            //Account for anonymous modules\n            context.completeLoad(moduleName);\n        }\n        return null;\n    };\n\n    //Look for a data-main script attribute, which could also adjust the baseUrl.\n    if (isBrowser) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        scripts = document.getElementsByTagName(\"script\");\n\n        for (i = scripts.length - 1; i > -1 && (script = scripts[i]); i--) {\n            //Set the \"head\" where we can append children by\n            //using the script's parent.\n            if (!head) {\n                head = script.parentNode;\n            }\n\n            //Look for a data-main attribute to set main script for the page\n            //to load. If it is there, the path to data main becomes the\n            //baseUrl, if it is not already set.\n            if ((dataMain = script.getAttribute('data-main'))) {\n                if (!cfg.baseUrl) {\n                    //Pull off the directory of data-main for use as the\n                    //baseUrl.\n                    src = dataMain.split('/');\n                    mainScript = src.pop();\n                    subPath = src.length ? src.join('/')  + '/' : './';\n\n                    //Set final config.\n                    cfg.baseUrl = subPath;\n                    //Strip off any trailing .js since dataMain is now\n                    //like a module name.\n                    dataMain = mainScript.replace(jsSuffixRegExp, '');\n                }\n\n                //Put the data-main script in the files to load.\n                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];\n\n                break;\n            }\n        }\n    }\n\n    //Set baseUrl based on config.\n    s.baseUrl = cfg.baseUrl;\n\n    //****** START page load functionality ****************\n    /**\n     * Sets the page as loaded and triggers check for all modules loaded.\n     */\n    req.pageLoaded = function () {\n        if (!s.isPageLoaded) {\n            s.isPageLoaded = true;\n            if (scrollIntervalId) {\n                clearInterval(scrollIntervalId);\n            }\n\n            //Part of a fix for FF < 3.6 where readyState was not set to\n            //complete so libraries like jQuery that check for readyState\n            //after page load where not getting initialized correctly.\n            //Original approach suggested by Andrea Giammarchi:\n            //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n            //see other setReadyState reference for the rest of the fix.\n            if (setReadyState) {\n                document.readyState = \"complete\";\n            }\n\n            req.callReady();\n        }\n    };\n\n    //See if there is nothing waiting across contexts, and if not, trigger\n    //callReady.\n    req.checkReadyState = function () {\n        var contexts = s.contexts, prop;\n        for (prop in contexts) {\n            if (!(prop in empty)) {\n                if (contexts[prop].waitCount) {\n                    return;\n                }\n            }\n        }\n        s.isDone = true;\n        req.callReady();\n    };\n\n    /**\n     * Internal function that calls back any ready functions. If you are\n     * integrating RequireJS with another library without require.ready support,\n     * you can define this method to call your page ready code instead.\n     */\n    req.callReady = function () {\n        var callbacks = s.readyCalls, i, callback, contexts, context, prop;\n\n        if (s.isPageLoaded && s.isDone) {\n            if (callbacks.length) {\n                s.readyCalls = [];\n                for (i = 0; (callback = callbacks[i]); i++) {\n                    callback();\n                }\n            }\n\n            //If jQuery with readyWait is being tracked, updated its\n            //readyWait count.\n            contexts = s.contexts;\n            for (prop in contexts) {\n                if (!(prop in empty)) {\n                    context = contexts[prop];\n                    if (context.jQueryIncremented) {\n                        context.jQuery.ready(true);\n                        context.jQueryIncremented = false;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Registers functions to call when the page is loaded\n     */\n    req.ready = function (callback) {\n        if (s.isPageLoaded && s.isDone) {\n            callback();\n        } else {\n            s.readyCalls.push(callback);\n        }\n        return req;\n    };\n\n    if (isBrowser) {\n        if (document.addEventListener) {\n            //Standards. Hooray! Assumption here that if standards based,\n            //it knows about DOMContentLoaded.\n            document.addEventListener(\"DOMContentLoaded\", req.pageLoaded, false);\n            window.addEventListener(\"load\", req.pageLoaded, false);\n            //Part of FF < 3.6 readystate fix (see setReadyState refs for more info)\n            if (!document.readyState) {\n                setReadyState = true;\n                document.readyState = \"loading\";\n            }\n        } else if (window.attachEvent) {\n            window.attachEvent(\"onload\", req.pageLoaded);\n\n            //DOMContentLoaded approximation, as found by Diego Perini:\n            //http://javascript.nwbox.com/IEContentLoaded/\n            if (self === self.top) {\n                scrollIntervalId = setInterval(function () {\n                    try {\n                        //From this ticket:\n                        //http://bugs.dojotoolkit.org/ticket/11106,\n                        //In IE HTML Application (HTA), such as in a selenium test,\n                        //javascript in the iframe can't see anything outside\n                        //of it, so self===self.top is true, but the iframe is\n                        //not the top window and doScroll will be available\n                        //before document.body is set. Test document.body\n                        //before trying the doScroll trick.\n                        if (document.body) {\n                            document.documentElement.doScroll(\"left\");\n                            req.pageLoaded();\n                        }\n                    } catch (e) {}\n                }, 30);\n            }\n        }\n\n        //Check if document already complete, and if so, just trigger page load\n        //listeners. NOTE: does not work with Firefox before 3.6. To support\n        //those browsers, manually call require.pageLoaded().\n        if (document.readyState === \"complete\") {\n            req.pageLoaded();\n        }\n    }\n    //****** END page load functionality ****************\n\n    //Set up default context. If require was a configuration object, use that as base config.\n    req(cfg);\n\n    //If modules are built into require.js, then need to make sure dependencies are\n    //traced. Use a setTimeout in the browser world, to allow all the modules to register\n    //themselves. In a non-browser env, assume that modules are not built into require.js,\n    //which seems odd to do on the server.\n    if (req.isAsync && typeof setTimeout !== \"undefined\") {\n        ctx = s.contexts[(cfg.context || defContextName)];\n        //Indicate that the script that includes require() is still loading,\n        //so that require()'d dependencies are not traced until the end of the\n        //file is parsed (approximated via the setTimeout call).\n        ctx.requireWait = true;\n        setTimeout(function () {\n            ctx.requireWait = false;\n\n            //Any modules included with the require.js file will be in the\n            //global queue, assign them to this context.\n            ctx.takeGlobalQueue();\n\n            //Allow for jQuery to be loaded/already in the page, and if jQuery 1.4.3,\n            //make sure to hold onto it for readyWait triggering.\n            ctx.jQueryCheck();\n\n            if (!ctx.scriptCount) {\n                ctx.resume();\n            }\n            req.checkReadyState();\n        }, 0);\n    }\n}());\n", 'require.js');

    //These are written out long-form so that they can be replaced by
    //the distribution script.
    if (env === 'rhino') {
        exec("/**\n * @license RequireJS rhino Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint strict: false */\n/*global require: false, java: false, load: false */\n\n(function () {\n\n    require.load = function (context, moduleName, url) {\n        //isDone is used by require.ready()\n        require.s.isDone = false;\n\n        //Indicate a the module is in process of loading.\n        context.loaded[moduleName] = false;\n        context.scriptCount += 1;\n\n        load(url);\n\n        //Support anonymous modules.\n        context.completeLoad(moduleName);\n    };\n\n    //Adapter to get text plugin to work.\n    require.fetchText = function (url, callback) {\n        var encoding = \"utf-8\",\n            file = new java.io.File(url),\n            lineSeparator = java.lang.System.getProperty(\"line.separator\"),\n            input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\n            stringBuffer, line,\n            content = '';\n        try {\n            stringBuffer = new java.lang.StringBuffer();\n            line = input.readLine();\n\n            // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\n            // http://www.unicode.org/faq/utf_bom.html\n\n            // Note that when we use utf-8, the BOM should appear as \"EF BB BF\", but it doesn't due to this bug in the JDK:\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\n            if (line && line.length() && line.charAt(0) === 0xfeff) {\n                // Eat the BOM, since we've already found the encoding on this file,\n                // and we plan to concatenating this buffer with others; the BOM should\n                // only appear at the top of a file.\n                line = line.substring(1);\n            }\n\n            stringBuffer.append(line);\n\n            while ((line = input.readLine()) !== null) {\n                stringBuffer.append(lineSeparator);\n                stringBuffer.append(line);\n            }\n            //Make sure we return a JavaScript string and not a Java string.\n            content = String(stringBuffer.toString()); //String\n        } finally {\n            input.close();\n        }\n        callback(content);\n    };\n\n}());", 'rhino.js');
    } else if (env === 'node') {
        exec("/**\n * @license RequireJS node Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n\n/*jslint regexp: false, strict: false */\n/*global require: false, define: false, nodeRequire: true, process: false */\n\n/**\n * This adapter assumes that x.js has loaded it and set up\n * some variables. This adapter just allows limited RequireJS\n * usage from within the requirejs directory. The general\n * node adapater is r.js.\n */\n(function () {\n    var req = nodeRequire,\n        fs = req('fs'),\n        path = req('path'),\n        vm = req('vm');\n\n    //Clear out the global set by x.js\n    nodeRequire = null;\n\n    //Make nodeRequire available off of require, to allow a script to\n    //add things to its require.paths for example.\n    require.nodeRequire = req;\n\n    //Supply an implementation that allows synchronous get of a module.\n    require.get = function (context, moduleName, relModuleMap) {\n        if (moduleName === \"require\" || moduleName === \"exports\" || moduleName === \"module\") {\n            require.onError(new Error(\"Explicit require of \" + moduleName + \" is not allowed.\"));\n        }\n\n        var ret,\n            moduleMap = context.makeModuleMap(moduleName, relModuleMap);\n\n        //Normalize module name, if it contains . or ..\n        moduleName = moduleMap.fullName;\n\n        if (moduleName in context.defined) {\n            ret = context.defined[moduleName];\n        } else {\n            if (ret === undefined) {\n                //Try to dynamically fetch it.\n                require.load(context, moduleName, moduleMap.url);\n                //The above call is sync, so can do the next thing safely.\n                ret = context.defined[moduleName];\n            }\n        }\n\n        return ret;\n    };\n\n    require.load = function (context, moduleName, url) {\n        var contents;\n\n        //isDone is used by require.ready()\n        require.s.isDone = false;\n\n        //Indicate a the module is in process of loading.\n        context.loaded[moduleName] = false;\n        context.scriptCount += 1;\n\n        if (path.existsSync(url)) {\n            contents = fs.readFileSync(url, 'utf8');\n            vm.runInThisContext(contents, url);\n        } else {\n            define(function () {\n                return req(moduleName);\n            });\n        }\n\n        //Support anonymous modules.\n        context.completeLoad(moduleName);\n    };\n\n    //Adapter to get text plugin to work.\n    require.fetchText = function (url, callback) {\n        callback(fs.readFileSync(url, 'utf8'));\n    };\n\n}());", 'node.js');
    }

    if (useRequireBuildPath) {
        exec("require({" +
            "baseUrl: '" + requireBuildPath + "build/jslib/'," +
            "paths: {" +
            "    require: '../../require'" +
            "}," +
            "argsHasRequirePath: true" +
        "})", 'bootstrap');
    }

    //Support a default file name to execute. Useful for hosted envs
    //like Joyent where it defaults to a server.js as the only executed
    //script.
    if (!fileName || !jsSuffixRegExp.test(fileName)) {
        fileName = 'main.js';
    }

    exec(readFile(fileName), fileName);

}((typeof Packages !== 'undefined' ? arguments : []), (typeof readFile !== 'undefined' ? readFile: undefined)));
